/* TypeScript file generated from ImportTsValue.res by genType. */
/* eslint-disable import/first */


import {integerValue as integerValueNotChecked} from './TypeBasics';

import {floatValue as floatValueNotChecked} from './TypeBasics';

import {binaryValue as binaryValueNotChecked} from './TypeBasics';

import {booleanValue as booleanValueNotChecked} from './TypeBasics';

import {booleanValue2 as booleanValue2NotChecked} from './TypeBasics';

import {stringValue as stringValueNotChecked} from './TypeBasics';

import {opValue1 as opValue1NotChecked} from './TypeBasics';

import {opValue2 as opValue2NotChecked} from './TypeBasics';

import {opValue3 as opValue3NotChecked} from './TypeBasics';

import {opValue4 as opValue4NotChecked} from './TypeBasics';

import {opValue5 as opValue5NotChecked} from './TypeBasics';

import {opValue6 as opValue6NotChecked} from './TypeBasics';

import {opValue7 as opValue7NotChecked} from './TypeBasics';

import {opValue8 as opValue8NotChecked} from './TypeBasics';

import {opValue11 as opValue11NotChecked} from './TypeBasics';

import {opValue12 as opValue12NotChecked} from './TypeBasics';

import {opValue21 as opValue21NotChecked} from './TypeBasics';

import {opValue22 as opValue22NotChecked} from './TypeBasics';

import {opValue23 as opValue23NotChecked} from './TypeBasics';

import {opValue31 as opValue31NotChecked} from './TypeBasics';

import {opValue32 as opValue32NotChecked} from './TypeBasics';

import {integerValueFromVar as integerValueFromVarNotChecked} from './TypeBasics';

import {integerList as integerListNotChecked} from './TypeRepertoire';

import {integerList2 as integerList2NotChecked} from './TypeRepertoire';

import {integerList3 as integerList3NotChecked} from './TypeRepertoire';

import {intstrTuple as intstrTupleNotChecked} from './TypeRepertoire';

import {intstrTuple2 as intstrTuple2NotChecked} from './TypeRepertoire';

import {enumValue as enumValueNotChecked} from './TypeRepertoire';

import {objectSimple as objectSimpleNotChecked} from './TypeRepertoire';

import {objectComplex as objectComplexNotChecked} from './TypeRepertoire';

import {funcInt2Int as funcInt2IntNotChecked} from './TypeRepertoire';

import {funcStr2Array as funcStr2ArrayNotChecked} from './TypeRepertoire';

import {funcPoint2Point as funcPoint2PointNotChecked} from './TypeRepertoire';

import {intORstrORnull as intORstrORnullNotChecked} from './TypeRepertoire';

import {unions as unionsNotChecked} from './TypeRepertoire';

import {returnMixedArray as returnMixedArrayNotChecked} from './TypeRepertoire';

import {useColor as useColorNotChecked} from './TypeRepertoire';

import {higherOrder as higherOrderNotChecked} from './TypeRepertoire';

import {convertVariant as convertVariantNotChecked} from './TypeRepertoire';

import {polymorphic as polymorphicNotChecked} from './TypeRepertoire';

import {default as defaultNotChecked} from './TypeRepertoire';

// @ts-ignore: Implicit any on import
import * as Curry__Es6Import from 'rescript/lib/es6/curry.js';
const Curry: any = Curry__Es6Import;

// In case of type error, check the type of 'integerValue' in 'ImportTsValue.re' and './TypeBasics'.
/* integerValue | TS: [number] | RES: [number] */
export const integerValueTypeChecked: number = integerValueNotChecked;

// Export 'integerValue' early to allow circular import from the '.bs.js' file.
export const integerValue: unknown = integerValueTypeChecked as number;

// In case of type error, check the type of 'floatValue' in 'ImportTsValue.re' and './TypeBasics'.
/* floatValue | TS: [number] | RES: [number] */
export const floatValueTypeChecked: number = floatValueNotChecked;

// Export 'floatValue' early to allow circular import from the '.bs.js' file.
export const floatValue: unknown = floatValueTypeChecked as number;

// In case of type error, check the type of 'binaryValue' in 'ImportTsValue.re' and './TypeBasics'.
/* binaryValue | TS: [number] | RES: [number] */
export const binaryValueTypeChecked: number = binaryValueNotChecked;

// Export 'binaryValue' early to allow circular import from the '.bs.js' file.
export const binaryValue: unknown = binaryValueTypeChecked as number;

// In case of type error, check the type of 'booleanValue' in 'ImportTsValue.re' and './TypeBasics'.
/* booleanValue | TS: [boolean] | RES: [boolean] */
export const booleanValueTypeChecked: boolean = booleanValueNotChecked;

// Export 'booleanValue' early to allow circular import from the '.bs.js' file.
export const booleanValue: unknown = booleanValueTypeChecked as boolean;

// In case of type error, check the type of 'booleanValue2' in 'ImportTsValue.re' and './TypeBasics'.
/* booleanValue2 | TS: [boolean] | RES: [boolean] */
export const booleanValue2TypeChecked: boolean = booleanValue2NotChecked;

// Export 'booleanValue2' early to allow circular import from the '.bs.js' file.
export const booleanValue2: unknown = booleanValue2TypeChecked as boolean;

// In case of type error, check the type of 'stringValue' in 'ImportTsValue.re' and './TypeBasics'.
/* stringValue | TS: [string] | RES: [string] */
export const stringValueTypeChecked: string = stringValueNotChecked;

// Export 'stringValue' early to allow circular import from the '.bs.js' file.
export const stringValue: unknown = stringValueTypeChecked as string;

// In case of type error, check the type of 'opValue1' in 'ImportTsValue.re' and './TypeBasics'.
/* opValue1 | TS: [number] | RES: [number] */
export const opValue1TypeChecked: number = opValue1NotChecked;

// Export 'opValue1' early to allow circular import from the '.bs.js' file.
export const opValue1: unknown = opValue1TypeChecked as number;

// In case of type error, check the type of 'opValue2' in 'ImportTsValue.re' and './TypeBasics'.
/* opValue2 | TS: [number] | RES: [number] */
export const opValue2TypeChecked: number = opValue2NotChecked;

// Export 'opValue2' early to allow circular import from the '.bs.js' file.
export const opValue2: unknown = opValue2TypeChecked as number;

// In case of type error, check the type of 'opValue3' in 'ImportTsValue.re' and './TypeBasics'.
/* opValue3 | TS: [Complicated or Undefined] | RES: [number] */
export const opValue3TypeChecked: number = opValue3NotChecked;

// Export 'opValue3' early to allow circular import from the '.bs.js' file.
export const opValue3: unknown = opValue3TypeChecked as number;

// In case of type error, check the type of 'opValue4' in 'ImportTsValue.re' and './TypeBasics'.
/* opValue4 | TS: [number] | RES: [number] */
export const opValue4TypeChecked: number = opValue4NotChecked;

// Export 'opValue4' early to allow circular import from the '.bs.js' file.
export const opValue4: unknown = opValue4TypeChecked as number;

// In case of type error, check the type of 'opValue5' in 'ImportTsValue.re' and './TypeBasics'.
/* opValue5 | TS: [Go deeper] | RES: [number] */
export const opValue5TypeChecked: number = opValue5NotChecked;

// Export 'opValue5' early to allow circular import from the '.bs.js' file.
export const opValue5: unknown = opValue5TypeChecked as number;

// In case of type error, check the type of 'opValue6' in 'ImportTsValue.re' and './TypeBasics'.
/* opValue6 | TS: [Go deeper] | RES: [number] */
export const opValue6TypeChecked: number = opValue6NotChecked;

// Export 'opValue6' early to allow circular import from the '.bs.js' file.
export const opValue6: unknown = opValue6TypeChecked as number;

// In case of type error, check the type of 'opValue7' in 'ImportTsValue.re' and './TypeBasics'.
/* opValue7 | TS: [Complicated or Undefined] | RES: [number] */
export const opValue7TypeChecked: number = opValue7NotChecked;

// Export 'opValue7' early to allow circular import from the '.bs.js' file.
export const opValue7: unknown = opValue7TypeChecked as number;

// In case of type error, check the type of 'opValue8' in 'ImportTsValue.re' and './TypeBasics'.
/* opValue8 | TS: [Complicated or Undefined] | RES: [number] */
export const opValue8TypeChecked: number = opValue8NotChecked;

// Export 'opValue8' early to allow circular import from the '.bs.js' file.
export const opValue8: unknown = opValue8TypeChecked as number;

// In case of type error, check the type of 'opValue11' in 'ImportTsValue.re' and './TypeBasics'.
/* opValue11 | TS: [boolean] | RES: [boolean] */
export const opValue11TypeChecked: boolean = opValue11NotChecked;

// Export 'opValue11' early to allow circular import from the '.bs.js' file.
export const opValue11: unknown = opValue11TypeChecked as boolean;

// In case of type error, check the type of 'opValue12' in 'ImportTsValue.re' and './TypeBasics'.
/* opValue12 | TS: [boolean] | RES: [boolean] */
export const opValue12TypeChecked: boolean = opValue12NotChecked;

// Export 'opValue12' early to allow circular import from the '.bs.js' file.
export const opValue12: unknown = opValue12TypeChecked as boolean;

// In case of type error, check the type of 'opValue21' in 'ImportTsValue.re' and './TypeBasics'.
/* opValue21 | TS: [Go deeper] | RES: [boolean] */
export const opValue21TypeChecked: boolean = opValue21NotChecked;

// Export 'opValue21' early to allow circular import from the '.bs.js' file.
export const opValue21: unknown = opValue21TypeChecked as boolean;

// In case of type error, check the type of 'opValue22' in 'ImportTsValue.re' and './TypeBasics'.
/* opValue22 | TS: [Go deeper] | RES: [boolean] */
export const opValue22TypeChecked: boolean = opValue22NotChecked;

// Export 'opValue22' early to allow circular import from the '.bs.js' file.
export const opValue22: unknown = opValue22TypeChecked as boolean;

// In case of type error, check the type of 'opValue23' in 'ImportTsValue.re' and './TypeBasics'.
/* opValue23 | TS: [Complicated or Undefined] | RES: [number] */
export const opValue23TypeChecked: number = opValue23NotChecked;

// Export 'opValue23' early to allow circular import from the '.bs.js' file.
export const opValue23: unknown = opValue23TypeChecked as number;

// In case of type error, check the type of 'opValue31' in 'ImportTsValue.re' and './TypeBasics'.
/* opValue31 | TS: [number] | RES: [string] */
export const opValue31TypeChecked: string = opValue31NotChecked;

// Export 'opValue31' early to allow circular import from the '.bs.js' file.
export const opValue31: unknown = opValue31TypeChecked as string;

// In case of type error, check the type of 'opValue32' in 'ImportTsValue.re' and './TypeBasics'.
/* opValue32 | TS: [number] | RES: [string] */
export const opValue32TypeChecked: string = opValue32NotChecked;

// Export 'opValue32' early to allow circular import from the '.bs.js' file.
export const opValue32: unknown = opValue32TypeChecked as string;

// In case of type error, check the type of 'integerValueFromVar' in 'ImportTsValue.re' and './TypeBasics'.
/* integerValueFromVar | TS: [Complicated or Undefined] | RES: [number] */
export const integerValueFromVarTypeChecked: number = integerValueFromVarNotChecked;

// Export 'integerValueFromVar' early to allow circular import from the '.bs.js' file.
export const integerValueFromVar: unknown = integerValueFromVarTypeChecked as number;

// In case of type error, check the type of 'integerList' in 'ImportTsValue.re' and './TypeRepertoire'.
/* integerList | TS: [Complicated or Undefined] | RES: [number[]] */
export const integerListTypeChecked: number[] = integerListNotChecked;

// Export 'integerList' early to allow circular import from the '.bs.js' file.
export const integerList: unknown = integerListTypeChecked as number[];

// In case of type error, check the type of 'integerList2' in 'ImportTsValue.re' and './TypeRepertoire'.
/* integerList2 | TS: [number[]] | RES: [number[]] */
export const integerList2TypeChecked: number[] = integerList2NotChecked;

// Export 'integerList2' early to allow circular import from the '.bs.js' file.
export const integerList2: unknown = integerList2TypeChecked as number[];

// In case of type error, check the type of 'integerList3' in 'ImportTsValue.re' and './TypeRepertoire'.
/* integerList3 | TS: [Array<number>] | RES: [number[]] */
export const integerList3TypeChecked: number[] = integerList3NotChecked;

// Export 'integerList3' early to allow circular import from the '.bs.js' file.
export const integerList3: unknown = integerList3TypeChecked as number[];

// In case of type error, check the type of 'intstrTuple' in 'ImportTsValue.re' and './TypeRepertoire'.
/* intstrTuple | TS: [Complicated or Undefined] | RES: [numberOrString[]] */
export const intstrTupleTypeChecked: numberOrString[] = intstrTupleNotChecked;

// Export 'intstrTuple' early to allow circular import from the '.bs.js' file.
export const intstrTuple: unknown = intstrTupleTypeChecked as numberOrString[];

// In case of type error, check the type of 'intstrTuple2' in 'ImportTsValue.re' and './TypeRepertoire'.
/* intstrTuple2 | TS: [[number, string]] | RES: [[number, string]] */
export const intstrTuple2TypeChecked: [number, string] = intstrTuple2NotChecked;

// Export 'intstrTuple2' early to allow circular import from the '.bs.js' file.
export const intstrTuple2: unknown = intstrTuple2TypeChecked as [number, string];

// In case of type error, check the type of 'enumValue' in 'ImportTsValue.re' and './TypeRepertoire'.
/* enumValue | TS: [Complicated or Undefined] | RES: [number] */
export const enumValueTypeChecked: number = enumValueNotChecked;

// Export 'enumValue' early to allow circular import from the '.bs.js' file.
export const enumValue: unknown = enumValueTypeChecked as number;

// In case of type error, check the type of 'objectSimple' in 'ImportTsValue.re' and './TypeRepertoire'.
/* objectSimple | TS: [Complicated or Undefined] | RES: [pointRequired_rescript] */
export const objectSimpleTypeChecked: pointRequired_rescript = objectSimpleNotChecked;

// Export 'objectSimple' early to allow circular import from the '.bs.js' file.
export const objectSimple: unknown = objectSimpleTypeChecked as pointRequired_rescript;

// In case of type error, check the type of 'objectComplex' in 'ImportTsValue.re' and './TypeRepertoire'.
/* objectComplex | TS: [Complicated or Undefined] | RES: [objectComplexT] */
export const objectComplexTypeChecked: objectComplexT = objectComplexNotChecked;

// Export 'objectComplex' early to allow circular import from the '.bs.js' file.
export const objectComplex: unknown = objectComplexTypeChecked as objectComplexT;

// In case of type error, check the type of 'funcInt2Int' in 'ImportTsValue.re' and './TypeRepertoire'.
/* funcInt2Int | TS: [number] | RES: [(_1:number) => number] */
export const funcInt2IntTypeChecked: (_1:number) => number = funcInt2IntNotChecked;

// Export 'funcInt2Int' early to allow circular import from the '.bs.js' file.
export const funcInt2Int: unknown = funcInt2IntTypeChecked as (_1:number) => number;

// In case of type error, check the type of 'funcStr2Array' in 'ImportTsValue.re' and './TypeRepertoire'.
/* funcStr2Array | TS: [number[]] | RES: [(_1:string) => number[]] */
export const funcStr2ArrayTypeChecked: (_1:string) => number[] = funcStr2ArrayNotChecked;

// Export 'funcStr2Array' early to allow circular import from the '.bs.js' file.
export const funcStr2Array: unknown = funcStr2ArrayTypeChecked as (_1:string) => number[];

// In case of type error, check the type of 'funcPoint2Point' in 'ImportTsValue.re' and './TypeRepertoire'.
/* funcPoint2Point | TS: [pointRequired] | RES: [(_1:pointOptional_rescript) => pointRequired_rescript] */
export const funcPoint2PointTypeChecked: (_1:pointOptional_rescript) => pointRequired_rescript = funcPoint2PointNotChecked;

// Export 'funcPoint2Point' early to allow circular import from the '.bs.js' file.
export const funcPoint2Point: unknown = funcPoint2PointTypeChecked as (_1:pointOptional_rescript) => pointRequired_rescript;

// In case of type error, check the type of 'intORstrORnull' in 'ImportTsValue.re' and './TypeRepertoire'.
/* intORstrORnull | TS: [number] | RES: [numberOrStringOrNull] */
export const intORstrORnullTypeChecked: numberOrStringOrNull = intORstrORnullNotChecked;

// Export 'intORstrORnull' early to allow circular import from the '.bs.js' file.
export const intORstrORnull: unknown = intORstrORnullTypeChecked as numberOrStringOrNull;

// In case of type error, check the type of 'unions' in 'ImportTsValue.re' and './TypeRepertoire'.
/* unions | TS: [string] | RES: [complexUnion] */
export const unionsTypeChecked: complexUnion = unionsNotChecked;

// Export 'unions' early to allow circular import from the '.bs.js' file.
export const unions: unknown = unionsTypeChecked as complexUnion;

// In case of type error, check the type of 'returnMixedArray' in 'ImportTsValue.re' and './TypeRepertoire'.
/* returnMixedArray | TS: [Array<number | string>] | RES: [() => numberOrString[]] */
export const returnMixedArrayTypeChecked: () => numberOrString[] = returnMixedArrayNotChecked;

// Export 'returnMixedArray' early to allow circular import from the '.bs.js' file.
export const returnMixedArray: unknown = returnMixedArrayTypeChecked as () => numberOrString[];

// In case of type error, check the type of 'useColor' in 'ImportTsValue.re' and './TypeRepertoire'.
/* useColor | TS: [number] | RES: [(_1:color) => number] */
export const useColorTypeChecked: (_1:color) => number = useColorNotChecked;

// Export 'useColor' early to allow circular import from the '.bs.js' file.
export const useColor: unknown = useColorTypeChecked as (_1:color) => number;

// In case of type error, check the type of 'higherOrder' in 'ImportTsValue.re' and './TypeRepertoire'.
/* higherOrder | TS: [(_1: number, _2: number) => number => unknown] | RES: [(_1:((_1:number, _2:number) => number)) => number] */
export const higherOrderTypeChecked: (_1:((_1:number, _2:number) => number)) => number = higherOrderNotChecked;

// Export 'higherOrder' early to allow circular import from the '.bs.js' file.
export const higherOrder: unknown = function (Arg1: any) {
  const result = higherOrderTypeChecked(function (Arg11: any, Arg2: any) {
      const result1 = Curry._2(Arg1, Arg11, Arg2);
      return result1
    });
  return result
} as (_1:((_1:number, _2:number) => number)) => number;

// In case of type error, check the type of 'convertVariant' in 'ImportTsValue.re' and './TypeRepertoire'.
/* convertVariant | TS: [any => unknown] | RES: [(_1:variant) => variant] */
export const convertVariantTypeChecked: (_1:variant) => variant = convertVariantNotChecked;

// Export 'convertVariant' early to allow circular import from the '.bs.js' file.
export const convertVariant: unknown = function (Arg1: any) {
  const result = convertVariantTypeChecked(Arg1.TAG===0
    ? {tag:"I", value:Arg1._0}
    : {tag:"S", value:Arg1._0});
  return result.tag==="I"
    ? {TAG: 0, _0:result.value} as any
    : {TAG: 1, _0:result.value} as any
} as (_1:variant) => variant;

// In case of type error, check the type of 'polymorphic' in 'ImportTsValue.re' and './TypeRepertoire'.
/* polymorphic | TS: [T => unknown] | RES: [<a>(_1:a) => a] */
export const polymorphicTypeChecked: <a>(_1:a) => a = polymorphicNotChecked;

// Export 'polymorphic' early to allow circular import from the '.bs.js' file.
export const polymorphic: unknown = polymorphicTypeChecked as <a>(_1:a) => a;

// In case of type error, check the type of 'default' in 'ImportTsValue.re' and './TypeRepertoire'.
/* default | TS: [Default or NotFound] | RES: [number] */
export const defaultTypeChecked: number = defaultNotChecked;

// Export '$$default' early to allow circular import from the '.bs.js' file.
export const $$default: unknown = defaultTypeChecked as number;

// tslint:disable-next-line:no-var-requires
const ImportTsValueBS = require('./ImportTsValue.bs');

import type {AbsoluteValue as $$AbsoluteValue_t} from './TypeRepertoire';

import type {colorEnum as $$colorEnum} from './TypeRepertoire';

import type {complexUnion as $$complexUnion} from './TypeRepertoire';

import type {num as $$myNum} from './TypeRepertoire';

import type {num as $$num} from './TypeRepertoire';

import type {numberOrStringOrNull as $$numberOrStringOrNull} from './TypeRepertoire';

import type {numberOrString as $$numberOrString} from './TypeRepertoire';

import type {polyType as $$polyType} from './TypeRepertoire';

import type {stringFunction as $$stringFunction} from './TypeRepertoire';

// tslint:disable-next-line:interface-over-type-literal
export type numberOrString = $$numberOrString;

// tslint:disable-next-line:interface-over-type-literal
export type colorEnum = $$colorEnum;

// tslint:disable-next-line:interface-over-type-literal
export type pointRequired_rescript = { readonly x: number; readonly y: number };

// tslint:disable-next-line:interface-over-type-literal
export type pointOptional_rescript = { readonly x: number; readonly y?: number };

// tslint:disable-next-line:interface-over-type-literal
export type deepdeep = { readonly object1: pointRequired_rescript };

// tslint:disable-next-line:interface-over-type-literal
export type deep = { readonly deepdeep: deepdeep };

// tslint:disable-next-line:interface-over-type-literal
export type objectComplexT = { readonly object: pointRequired_rescript; readonly deep: deep };

// tslint:disable-next-line:interface-over-type-literal
export type numberOrStringOrNull = $$numberOrStringOrNull;

// tslint:disable-next-line:interface-over-type-literal
export type complexUnion = $$complexUnion;

// tslint:disable-next-line:interface-over-type-literal
export type AbsoluteValue_t = $$AbsoluteValue_t;

// tslint:disable-next-line:interface-over-type-literal
export type stringFunction = $$stringFunction;

// tslint:disable-next-line:interface-over-type-literal
export type color = "tomato" | "gray";

// tslint:disable-next-line:interface-over-type-literal
export type variant = 
    { tag: "I"; value: number }
  | { tag: "S"; value: string };

// tslint:disable-next-line:interface-over-type-literal
export type num = $$num;

// tslint:disable-next-line:interface-over-type-literal
export type myNum = $$myNum;

// tslint:disable-next-line:interface-over-type-literal
export type polyType<a> = $$polyType<a>;

export const funcInt2IntRet: number = ImportTsValueBS.funcInt2IntRet;

export const useGetProp: (x:AbsoluteValue_t) => number = ImportTsValueBS.useGetProp;

export const useGetAbs: (x:AbsoluteValue_t) => number = ImportTsValueBS.useGetAbs;

export const returnedFromHigherOrder: number = ImportTsValueBS.returnedFromHigherOrder;

export default $$default;

// Hi this is the point where string is finally emitted!! VKJY
